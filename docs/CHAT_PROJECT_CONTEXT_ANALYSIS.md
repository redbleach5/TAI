# Взаимодействие чата с открытым проектом — анализ и улучшения

## Текущее состояние

### 1. Что уже работает

**Открытые файлы (context_files, Cursor-like)**  
- Фронт (`OpenFilesContext.getContextFiles`) собирает все открытые в редакторе файлы (активный первым) и отправляет в чат как `context_files`.  
- Бэкенд добавляет их в user message как блок `[Context - open files in IDE]` с путём и полным содержимым.  
- В **обычном чате** контент файлов передаётся целиком.  
- В **режиме агента** каждый файл обрезается до **2000 символов** (`f.content[:2000]` в `agent/use_case.py`).

**Команды @code / @file**  
- Пользователь может явно подключать файлы по пути: `@code src/main.py`, `@file frontend/package.json`.  
- Обработчик `FileReaderHandler` читает файл с диска и вставляет содержимое в контекст (лимит 10 000 символов на файл).

**RAG и карта проекта**  
- При индексации workspace (кнопка «Индексировать» / выбор проекта) RAG индексирует файлы **текущего workspace** (projects store).  
- В чате без `@rag` выполняется **auto-RAG**: по тексту сообщения подтягиваются релевантные чанки и добавляются в контекст.  
- В **режиме агента** дополнительно в system prompt подмешивается **project map** (структура проекта, до 2000 символов) и RAG-контекст по запросу.

**Агент и workspace**  
- `ToolExecutor` использует **workspace** из projects store (`_get_workspace_path()` → `get_store().get_current()`).  
- Инструменты `read_file`, `write_file`, `list_files`, `run_terminal` работают относительно корня этого workspace.  
- Открытые файлы передаются агенту как `[Open files]` в user message.

**Files API**  
- Чтение/запись файлов в UI (`/api/files/read`, `/api/files/write`) используют **workspace** через `_get_workspace_path()` в `files.py`.

---

### 2. Проблемы и несоответствия

| Компонент | Проблема |
|-----------|----------|
| **FileReaderHandler (@code / @file)** | Использует `Path.cwd()` (рабочая директория процесса), а не **workspace** из projects store. Если сервер запущен из другой папки или нет «текущего» проекта, пути вроде `src/main.py` разрешаются относительно неправильного корня. |
| **ChatRequest** | Не содержит `workspace_path`. Бэкенд всегда полагается на «текущий» проект из store. При нескольких проектах или до открытия папки контекст может быть неоднозначным. |
| **Агент: context_files** | Жёсткое ограничение 2000 символов на файл может обрезать большие открытые файлы; нет настройки лимита. |
| **UI** | Показывается только количество открытых файлов («AI видит N файлов»), без списка путей — пользователь не видит, какие именно файлы в контексте. |
| **Активный файл** | Не передаётся явно: активный файл лишь первый в списке `context_files`. Для промптов типа «измени текущий файл» явного поля `active_file_path` нет. |

---

## Что нужно для улучшения

### Критично (исправить баги)

1. **FileReaderHandler — использовать workspace**  
   - В `_process_commands` (или при вызове registry) передавать в контекст `workspace_path` (например из `workspace._get_workspace_path()` или аналога).  
   - В `FileReaderHandler.execute` использовать этот `workspace_path` как базу для разрешения путей вместо `Path.cwd()`.  
   - Так команды `@code`/`@file` будут согласованы с Files API и агентом.

### Желательно (улучшение контекста и UX)

2. **Опционально передавать workspace в запросе**  
   - Добавить в `ChatRequest` поле `workspace_path?: string` (или `project_id`).  
   - Фронт при наличии workspace может передавать путь/ид текущего проекта; бэкенд использовать его для команд и контекста, с fallback на store.  
   - Полезно при нескольких проектах и для явной привязки чата к проекту.

3. **Активный файл в запросе**  
   - Добавить в запрос поле `active_file_path?: string` и при сборке контекста помечать его в промпте (например «Current file: …»).  
   - Даёт модели однозначное понимание «текущего» файла для ответов в духе «измени здесь».

4. **Лимит context_files в агенте**  
   - Сделать лимит символов на файл настраиваемым (конфиг/константа) или считать по токенам, чтобы не обрезать большие файлы без контроля.

5. **UI: список файлов в контексте**  
   - В шапке чата рядом с «N файлов» показывать список путей открытых файлов (например, выпадающий список или тултип).  
   - Пользователь будет видеть, что именно видит модель.

### Дополнительно

6. **Структура проекта в обычном чате**  
   - Сейчас project map используется только в агенте. Для обычного чата можно опционально добавлять краткую структуру (дерево папок/файлов) в system или user message, чтобы модель лучше ориентировалась в проекте.

7. **Документация для пользователя**  
   - В UI или справке кратко описать: какие файлы попадают в контекст (открытые в редакторе), как работают @code/@file/@rag, что для RAG нужна индексация workspace.

---

## Краткая схема потока контекста

```
[Фронт]
  workspace (текущая папка) → Projects store / UI
  открытые файлы (OpenFilesContext) → context_files в ChatRequest
  активный файл → только порядок (первый в списке)

[Запрос чата]
  message, history, mode_id, model?, context_files?

[Бэкенд — обычный чат]
  - context_files → "[Context - open files in IDE]" в user message
  - @code / @file → FileReaderHandler (сейчас cwd, нужно workspace)
  - @rag / auto-RAG → RAG по текущему workspace (store)
  - Результат команд и RAG склеиваются в user message

[Бэкенд — агент]
  - context_files → "[Open files]" (обрезано 2000 симв/файл)
  - RAG + project map → system/user из store
  - ToolExecutor → workspace из get_store().get_current()
  - Инструменты read_file/write_file/… относительно этого workspace
```

Исправление **FileReaderHandler** на использование workspace и при необходимости передача **workspace_path/active_file_path** в запросе дадут максимальный эффект для согласованного взаимодействия моделей с открытым проектом через чат.

---

## Реализованные улучшения (Cursor-like UX)

- **FileReaderHandler** использует `workspace_path` из контекста команд (из projects store), а не `Path.cwd()`. Команды `@code`/`@file` разрешают пути относительно открытого проекта.
- **ChatRequest** поддерживает `active_file_path` — путь активной вкладки. В промпте добавляется подсказка «Current file (user is focused on): …», чтобы модель знала, с каким файлом работает пользователь.
- **Обычный чат** автоматически получает краткую **карту структуры проекта** (до 1500 символов) из RAG, если она есть — модель видит layout проекта без @.
- **Открытые файлы** оформлены в промпте как «Open files in editor — use these for context»; модель видит их без команд @code/@file.
- **Фронт:** отправляет `active_file_path`; в шапке чата отображается количество открытых файлов и по наведению — список путей; placeholder поля ввода при наличии контекста: «Чем помочь? AI видит открытые файлы.»; подсказки команд уточнены (добавить «ещё» файл по пути).
- **Удобство:** пользователь может просто писать в чат — модель уже видит открытые файлы, текущий файл и (после индексации) структуру проекта и релевантный код через auto-RAG. Команды @ остаются для явного добавления файла по пути или веб-поиска.
